####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

import json
from router import Router
from packet import Packet

INFINITY = 20 # Giá trị đại diện cho cost đến đích lớn, tránh vòng lặp

class DVrouter(Router):
    def __init__(self, addr, heartbeat_time):
        super().__init__(addr, heartbeat_time=heartbeat_time)
        # lưu heartbeat_time để handle_time
        self.heartbeat_time = heartbeat_time
        self.last_time = 0

        # state chính
        self.routing_table    = {addr: (0, addr)}  # dest -> (cost, next_hop)
        self.neighbor_vectors = {}                 # neighbor_addr -> their last sent vector
        self.link_costs       = {}                 # neighbor_addr -> direct link cost

        # maps port <-> neighbor để forwarding
        self.port_to_neighbor = {}
        self.neighbor_to_port = {}

    def handle_packet(self, port, packet):
        # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
        if packet.is_traceroute:
            dst = packet.dst_addr
            if dst in self.routing_table:
                next_hop = self.routing_table[dst][1]
                out_port = self.neighbor_to_port.get(next_hop)
                if out_port is not None:
                    self.send(out_port, packet)

         # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
        elif packet.is_routing:
            sender = packet.src_addr
            # ignore nếu sender đã mất link
            if sender not in self.link_costs:
                return

            vec = json.loads(packet.content)
            # chỉ cập nhật khi vector thay đổi
            if self.neighbor_vectors.get(sender) != vec:
                self.neighbor_vectors[sender] = vec
                self.recompute_table()
                self.broadcast_vector()

    def handle_new_link(self, port, endpoint, cost):
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        # lưu map để traceroute
        self.port_to_neighbor[port] = endpoint
        self.neighbor_to_port[endpoint] = port

        # cập nhật direct link cost và khởi vector neighbor
        self.link_costs[endpoint] = cost
        self.neighbor_vectors[endpoint] = {endpoint: 0}

        self.recompute_table()
        self.broadcast_vector()

    def handle_remove_link(self, port):
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        if port not in self.port_to_neighbor:
            return
        nbr = self.port_to_neighbor.pop(port)
        self.neighbor_to_port.pop(nbr, None)
        self.link_costs.pop(nbr, None)
        self.neighbor_vectors.pop(nbr, None)

        self.recompute_table()
        self.broadcast_vector()

    def handle_time(self, time_ms):
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            self.broadcast_vector()

    def update_routing_table(self):
     my_addr = self.addr
     new_routes = {my_addr: (0, my_addr)}  # Tới chính mình cost=0
    
     # Duyệt qua tất cả hàng xóm
     for neighbor, neighbor_routes in self.neighbor_vectors.items():
        if neighbor not in self.link_costs:
            continue  # Bỏ qua nếu không có thông tin chi phí
            
        cost_to_neighbor = self.link_costs[neighbor]
        
        # Cập nhật đường đi qua hàng xóm này
        for dest, neighbor_cost in neighbor_routes.items():
            total_cost = cost_to_neighbor + neighbor_cost
            
            # Chỉ cập nhật nếu đường đi tốt hơn
            if total_cost < new_routes.get(dest, (INFINITY,))[0]:
                new_routes[dest] = (total_cost, neighbor)
    
     self.routing_table = new_routes

def send_routes_to_neighbors(self):
    """Gửi bảng định tuyến cho các hàng xóm, áp dụng Poisoned Reverse"""
    for neighbor, port in self.neighbor_to_port.items():
        # Tạo bảng định tuyến đặc biệt cho từng hàng xóm
        poisoned_routes = {}
        
        for dest, (cost, next_hop) in self.routing_table.items():
            # Nếu hàng xóm là next-hop thì báo cost=INFINITY (Poisoned Reverse)
            poisoned_routes[dest] = INFINITY if next_hop == neighbor else cost
        
        # Đóng gói và gửi đi
        pkt = Packet(Packet.ROUTING, self.addr, neighbor, json.dumps(poisoned_routes))
        self.send(port, pkt)

    def __repr__(self):
        return f"DVrouter(addr={self.addr}, neighbors={len(self.neighbors)}, routes={len(self.forwarding_table)})"